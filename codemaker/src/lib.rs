/* Copyright 2021 Ryan F Kelly
 *
 * Licensed under the Apache License (Version 2.0), or the MIT license,
 * (the "Licenses") at your option. You may not use this file except in
 * compliance with one of the Licenses. You may obtain copies of the
 * Licenses at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *    http://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the Licenses is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the Licenses for the specific language governing permissions and
 * limitations under the Licenses. */

//! # A structured approach to generating source code.
//!
//! The [`codemaker`] crate provides abstractions to help you turn an in-memory data
//! structure into source code on disk in a way designed for flexibility, maintainability,
//! and code re-use.
//!
//! For example, suppose that you need a program to read a `.yaml` configuration
//! file and generate some Python code based on the data therein:
//!
//! TODO: box diagram
//!
//! The [`codemaker`] crate and its ecosystem can help you write such a program by
//! splitting up the task into composable parts:
//!
//!  1. Find (or perhaps write!) a [`codemaker`] "target" crate for the desired output format;
//!     in this case there is an existing [`codemaker_python`] crate that provides a builder
//!     API for generating Python source code.
//!  2. Write code to parse the `.yaml` file into an in-memory data structure; [`codemaker]`
//!     has no opinions on how to achieve this, but in practice you might use something from
//!     the `serde` ecosystem.
//!  3. Write code to transform the "source" data structure into one of the "target" data
//!     structures provided by the target crate; [`codemaker`] provides some traits and macros
//!     to help you do this in a structural rules-based manner.
//!  4. Render the desired output to disk; [`codemaker`] provides some traits to simplify the
//!     various fiddly details.
//!
//! Splitting the task into these separate parts has a number of potential benefits:
//!
//!   * The transformation rules can be tested independently using in-memory data structures,
//!     rather than having to test against the final rendered output.
//!   * A single target crate can be used by multiple different consumers who want to target
//!     the same output format.
//!   * A single consumer can target multiple output formats by adding transformation rules
//!     for multiple target crates.
//!
//! ## Writing a Target crate
//!
//! The core idea is that for a given output format "X", there is a single "codemaker_X" crate
//! that provides a builder API for generating output in that format. The precise details of that
//! API will depend on the details of the output format, but in general it should aim to:
//!
//!  * Provide an in-memory representation of code in the target format, along with
//!    utilities to inspect this representation for testing purposes.
//!  * Make it easy to generate nice-looking, idiomatic output in the target format.
//!  * Make it hard (or better, impossible!) to generate invalid output.
//!
//! The top-level data structures provided by a target crate will typically implement the
//! [`OutputFileSet`] trait, so that consumers can easily render the final output to disk.
//!
//! ## Writing a Consumer crate
//!
//! A consumer crate will depend on one or more target crates, and use the public APIs that they
//! provide in order to generate source code artifacts and render them to disk. It's welcome to
//! achieve this in whatever way is most convenient, but we expect that most consumers will
//! implement the [`CodeMaker`] trait to define the top-level input and output types and then use the
//! [`CodeMakerRule`] trait to implement a structural transformation from input type to output type.
//!
//! For example, suppose we have an in-memory data stucture `StatusCodes` that contains a list
//! of textual HTTP status names and their corresponding integer codes, perhaps parsed from a
//! `.yaml` file on disk:
//!
//! ```ignore
//! #[derive(Deserialize)]
//! struct StatusCodes {
//!     codes: Vec<(String, u32)>,
//! }
//! ```
//!
//! And we want to generate a Python module that defines each of these items as a global variable,
//! like this:
//!
//! ```python
//! # This is an autogenerated list of status codes.
//! CONTINUE = 100
//! OK = 200
//! CREATED = 201
//! MOVED_PERMANENTLY = 301
//! ...
//! ```
//!
//! To do so, we would first define a struct that is responsible for doing the code generation,
//! and which contains any additional configuration or state not found in the input data:
//!
//! ```ignore
//! struct PythonStatusModuleMaker {
//!    module_name: String,
//! }
//! ```
//!
//! This struct would implement the [`CodeMaker`] trait, which defines the expected input type
//! (our `StatusCodes` struct) and output type (here, a representation of a Python module from
//! the `codemaker_python` crate) of the code-generation process:
//!
//! ```ignore
//! use codemaker::{CodeMaker, define_codemaker_rules};
//! use codemaker_python as py;
//!
//! impl CodeMaker for PythonStatusModuleMaker {
//!   type Input = StatusCodes;
//!   type Output = py::Module;
//! }
//! ```
//!
//! We'd then write rules to generate a `Module` from the contents of a `StatusCodes` struct.
//! The most succinct way to do this is using the `define_codemaker_rules!` macro, like so:
//!
//! ```ignore
//! define_codemaker_rules!{
//!     PythonStatusModuleMaker as self {
//!         // The top-level `StatusCodes` object produces a python Module.
//!         StatusCodes as input => py::Module {
//!             py::Module::new(self.module_name.clone())
//!                 .add_comment("This is an autogenerated list of status codes.")
//!                 .extend(self.make_from_iter(input.codes.into_iter()))
//!         }
//!         // Each individual entry produces a variable assignment statement.
//!         (String, u32) as input => py::Assignment {
//!             py::Assignment::new(
//!                 py::Ident::new(input.0),
//!                 py::Literal::Int(input.1),
//!             )
//!         }
//!     }
//! }
//! ```
//!
//! The key part here is the call to `extend(self.make_from_iter(...))`, which delegates to the
//! rule defined for the individual entry type `(String, u2)`. This approach allows the code generation
//! rules to structurally decompose the input data structure, generating an appropriate fragment of
//! code for each of its parts and then assembling them together to produce the final output.
//!
//! The [`define_codemaker_rules!`] macro is syntactic suger over implementations of the
//! [`CodeMakerRule`] trait, and it's possible to implement this trait directly if the provided
//! macros do not meet your needs. Here is the equivalent rule for `StatusCodes` that would be
//! produced by the macro above:
//!
//! ```ignore
//! impl CodeMakerRule<StatusCodes, py::Module> for PythonStatusModuleMaker {
//!     fn make_from(&self, input: StatusCodes) -> py::Module {
//!         py::Module::new(self.name.clone())
//!             .add_comment("This is an autogenerated list of status codes.")
//!             .extend(self.make_from_iter(input.codes.into_iter()))
//!     }
//! }
//! ```
//!
//! Using the provided rules plus the traits and helper methods provided by the [`codemaker`] crate,
//! the Rust compiler will provide a `PythonStatusModuleMaker::make_from` method that accepts a
//! `StatusCodes` instance, walks its structure to generate Python code from its contents, and
//! returns a `py::Module` instance that can be rendered directly to disk:
//!
//! ```ignore
//! fn main() {
//!     // You'd implement loading of the data using `serde_yaml` or similar.
//!     let codes = StatusCodes::load_from_file("codes.yaml");
//!
//!     // You could read the module name from command-line args.
//!     let maker = PythonStatusModuleMaker { module_name: "status_codes" };
//!
//!     // This delegates to your `CodeMakerRule` implementations, then writes
//!     // the result out to disk.
//!     maker.make_from(codes)
//!          .write_into("my/output/directory");
//! }
//! ```
//!

#[cfg(test)]
mod tests;

/// A set of files produced by making some code.
///
/// This trait represents the end result of the code-generation process as a set of files
/// that can be written to disk. This is useful when the artifacts for a single distributable
/// unit of code must span multiple files, such as a Python package containing multiple
/// sub-modules.
///
/// CodeMaker target crates can impl this trait in their top-level data structures to let
/// consumers can easily write the resulting files to disk.
pub trait OutputFileSet {
    /// The type of the individual files contained in this set.
    type OutputFile: OutputFile;

    /// Iterator over output files produced by making some code.
    ///
    /// (This returns `Vec` because I can't work out how to make it return a
    /// generic iterator when defined on a trait, in a way that would avoid
    /// each implementor from having to spell out a concrete Iterator type).
    fn files(&self) -> Vec<&Self::OutputFile>;

    /// Write the output into the given base directory.
    ///
    /// Any missing directories will be created automatically, and I/O
    /// may result in partially-written output being left on disk.
    fn write_into_dir<P: AsRef<std::path::Path>>(&self, base_directory: P) -> std::io::Result<()> {
        let base_directory = base_directory.as_ref();
        for file in self.files() {
            let file_path = file.path();
            if !file_path.is_relative() {
                panic!("OutputFile returned non-relative path {:?}", file_path);
            }
            let file_path = base_directory.join(file.path());
            std::fs::create_dir_all(file_path.parent().unwrap_or(base_directory))?;
            let mut f = std::fs::File::create(file_path)?;
            file.write_into(&mut f)?;
        }
        Ok(())
    }
}

/// An individual file produced by making some code.
///
/// This trait represents the end result of the code-generation process as a single file
/// that can be written to disk. More complex cases that require multiple output files
/// should use the [`OutputFileSet`] trait.
///
/// CodeMaker target crates can impl this trait in their top-level data structures to let
/// consumers can easily write the resulting files to disk.
pub trait OutputFile {
    /// The path at which to write the file, relative to base output directory.
    ///
    /// Trait implementors must ensure that this returns a *relative* path, as trait
    /// consumers may panic if it does not.
    fn path(&self) -> &std::path::Path;

    /// Write the contents of this file into the given Writer.
    ///
    /// Trait consumers should implement this method to render the actual
    /// contents of the file.
    fn write_into<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()>;
}

/// Automatic impl of [`OutputFileSet`] for any [`OutputFile`].
///
/// This is a convenience implementation for rendering a single output file to disk,
/// provided automatically since there's really only one sensible way to represent
/// a set containing a single item.
impl<T> OutputFileSet for T
where
    T: OutputFile,
{
    type OutputFile = Self;
    fn files(&self) -> Vec<&Self> {
        vec![self]
    }
}

/// Top-level abstraction for converting a data structure into some code.
///
/// Each implementor of the [`CodeMaker`] trait is responsible for converting an
/// input data struture into an [`OutputFileSet`] that renders it somehow in code.
/// The precise details of said rendering into code will be controlled by providing
/// [`CodeMakerRule`] implementations that structurally map the input type `Self::Input`
/// to the output type `Self::Output`.
///
/// This trait doesn't actually *do* very much just yet, it's mostly designed to
/// help consumers form a correct mental model of how the pieces fit together.
/// The real action happens in the [`CodeMakerRule`] trait.
pub trait CodeMaker<'a>: CodeMakerRule<Self::Input, Self::Output> {
    type Input: 'a;
    type Output: OutputFileSet + 'a;

    fn make(&self, input: Self::Input) -> Self::Output {
        CodeMakerRule::<Self::Input, Self::Output>::make_from(self, input)
    }
}

/// An individual rule for making code by structural matching.
///
/// Consumers should implement [`CodeMakerRule<Input, Output>`] in order to make
/// a code artifact of type `Output` from a data structure of type `Input`, providing
/// a method `make_from(&self, i: Input) -> Output)`. This method may be conveniently
/// implemented by destructuring `Input` into its component parts, using additional
/// [`CodeMakerRule`] impls for each part, and then assembling the results into the
/// final `Output`.
///
/// The idea here is similar to the `From` trait, which helps you convert one type
/// into another by decomposing it into individual fields and calling `.from()` on
/// each of them in turn. Here we do something similar, but we use a [`CodeMaker`]
/// to carry additional context about how to do the transformation, and call its
/// `.make_from()` method an each part in turn.
///
/// Implementing this trait by hand is possible, but cumbersome; consider using
/// the [`define_codemaker_rules!`] macro to simplify the process of defining a
/// collection of such rules.
pub trait CodeMakerRule<Input, Output> {
    /// Make an instance of the output type from an instance of the input type.
    ///
    /// Consumers should provide a concrete implementation of this method for
    /// each desired input type and corresponding output type.
    fn make_from(&self, input: Input) -> Output;


    /// Conveniently map `make_from` over an iterator.
    ///
    /// This is a convenience method to map a [`CodeMakerRule`] over an iterator without having
    /// to explicitly wrap it in a closure. It can turn any `IntoIterator<Item=Input>` into an
    /// `Iterator<Item=Output>` for any of its possible `Input` and `Output` types supported by
    /// the trait implementor.
    ///
    /// Since we cannot use `impl Iterator` in a trait definition, we provide a concrete helper
    /// struct [`CodeMakerRuleMap`] that implements it for us. Please treat this struct as an
    /// internal implementation detail.
    fn make_from_iter<'a, I>(&'a self, input: I) -> CodeMakerRuleMap<'a, Input, Output, Self, I::IntoIter>
    where
        Self: CodeMakerRule<Input, Output>,
        I: IntoIterator<Item=Input> + 'a,
        Self: Sized,
        Input: 'a,
        Output: 'a,
    {
        CodeMakerRuleMap {
            maker: self,
            iter: input.into_iter(),
            phantom: std::marker::PhantomData,
        }
    }
}

/// Iterator mapping a [`CodeMakerRule`] over an input sequence.
///
/// This is a small helper struct for implementing [`CodeMakerRule`] over iterators
/// in a way that plays nicely with generics and lifetimes. We use it as the
/// return type of the trait default implementation, because we can't return
/// `impl Iterator` from trait methods and we don't want to have to box things.
pub struct CodeMakerRuleMap<'a, Input, Output, T, I>
where
    T: CodeMakerRule<Input, Output>,
    I: Iterator<Item = Input>,
    Input: 'a,
    Output: 'a,
{
    maker: &'a T,
    iter: I,
    // Not sure why this is needed, but Rust complains at me
    // about `Output` being unconstrained if I dont have it...
    phantom: std::marker::PhantomData<Output>,
}

impl<'a, Input, Output, T, I> Iterator for CodeMakerRuleMap<'a, Input, Output, T, I>
where
    T: CodeMakerRule<Input, Output>,
    I: Iterator<Item = Input>,
    Input: 'a,
    Output: 'a,
{
    type Item = Output;
    fn next(&mut self) -> Option<Output> {
        self.iter.next().map(|i| self.maker.make_from(i))
    }
}

/// Macro for generating a suite of [`CodeMakerRule`] implementations on a type.
///
/// There's a fair bit of boilerplate involved in defining a [`CodeMakerRule`], since
/// each Input/Output pair needs its own trait implementation. This macro helps avoid
/// a lot of the boilerplate by turning a call like this:
///
/// ```ignore
/// define_codemaker_rules!{
///     MyCodeMaker as self {
///         InputType1 as input => OutputType1 {
///             self.somehow_do_the_making(input)
///         }
///         InputType2 as input => OutputType2 {
///             self.do_different_making(input)
///         }
///         // ... and so on ...
///     }
/// }
/// ```
///
/// Into a suite of [`CodeMakerRule`] implementations on the `MyCodeMaker` type, one
/// for each of the provided `InputType`/`OutputType` pairs.
///
/// This macro uses a `Type as name` syntax for capturing the argument names of the
/// method calls that it will generate, rather than Rust's usual `name: Type` syntax.
/// This is designed to visually emphasize the mapping between the input type at the
/// start of the rule and the output type at the end. (The caller has to specify the
/// argument names explicitly because of Rust's macro hygiene trules, which prevent
/// the macro from injecting variables into your code).
#[macro_export]
macro_rules! define_codemaker_rules {
    ($CM:ty as $self:ident {
        $( $(#[$($attr:tt)+])* $In:ty as $input:pat => $Out:ty $body:block )*
    }) => {
        $(
            $(#[$($attr)+])*
            impl $crate::CodeMakerRule<$In, $Out> for $CM {
                fn make_from(&$self, $input: $In) -> $Out {
                    $body
                }
            }
        )*
    };
}


pub trait FluentAPI : Sized {
    fn edit<F: FnOnce(&mut Self)>(mut self, func: F) -> Self {
        func(&mut self);
        return self
    }
}

pub trait Extend<Item>: std::iter::Extend<Item> + FluentAPI {
    fn extend<I: Into<Item>, Iter: IntoIterator<Item=I>>(self, iter: Iter) -> Self {
        self.edit(|me| std::iter::Extend::extend(me, iter.into_iter().map(Into::into)))
    }
    fn push<I: Into<Item>>(self, item: I) -> Self {
        self.extend(std::iter::once(item))
    }
}

impl<T, Item> Extend<Item> for T where T: std::iter::Extend<Item> + FluentAPI {}